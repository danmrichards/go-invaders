package cpu

// defaultInstructionLen represents the default length of an instruction.
const defaultInstructionLen = 1

// opHandler is a function that handles the instruction for a given opcode and
// returns the number of bytes to increment the program counter by.
//
// In the majority of cases the returned value will be the length of the current
// instruction.
type opHandler func() uint16

// registerOpHandlers registers the map of opcode handlers.
func (i *Intel8080) registerOpHandlers() {
	i.opHandlers = map[byte]opHandler{
		0x00: i.nop,
		0x01: i.lxi(&i.b, &i.c),
		//0x02: stax("b"),
		0x03: i.inx(&i.b, &i.c),
		0x04: i.inr(&i.b),
		0x05: i.dcr(&i.b),
		0x06: i.mvi(&i.b),
		//0x07: rlc,
		0x08: i.ignore,
		0x09: i.dad(i.b, i.c),
		0x0a: i.ldax(i.b, i.c),
		0x0b: i.dcx(&i.b, &i.c),
		0x0c: i.inr(&i.c),
		0x0d: i.dcr(&i.c),
		0x0e: i.mvi(&i.c),
		0x0f: i.rrc,
		0x10: i.ignore,
		0x11: i.lxi(&i.d, &i.e),
		//0x12: stax("d"),
		0x13: i.inx(&i.d, &i.e),
		0x14: i.inr(&i.d),
		0x15: i.dcr(&i.d),
		0x16: i.mvi(&i.d),
		//0x17: ral,
		0x18: i.ignore,
		0x19: i.dad(i.d, i.e),
		0x1a: i.ldax(i.d, i.e),
		0x1b: i.dcx(&i.d, &i.e),
		0x1c: i.inr(&i.e),
		0x1d: i.dcr(&i.e),
		0x1e: i.mvi(&i.e),
		0x1f: i.rar,
		0x20: i.ignore,
		0x21: i.lxi(&i.h, &i.l),
		//0x22: shld,
		0x23: i.inx(&i.h, &i.l),
		0x24: i.inr(&i.h),
		0x25: i.dcr(&i.h),
		0x26: i.mvi(&i.h),
		0x27: i.daa,
		0x28: i.ignore,
		0x29: i.dad(i.h, i.l),
		//0x2a: lhld,
		0x2b: i.dcx(&i.h, &i.l),
		0x2c: i.inr(&i.l),
		0x2d: i.dcr(&i.l),
		0x2e: i.mvi(&i.l),
		0x2f: i.cma,
		0x30: i.ignore,
		0x31: i.lxiSP,
		0x32: i.sta,
		0x33: i.inxSP,
		0x34: i.inrM,
		0x35: i.dcrM,
		0x36: i.mviM,
		//0x37: stc,
		0x38: i.ignore,
		0x39: i.dadSP,
		0x3a: i.lda,
		0x3b: i.dcxSP,
		0x3c: i.inr(&i.a),
		0x3d: i.dcr(&i.a),
		0x3e: i.mvi(&i.a),
		//0x3f: cmc,
		0x40: i.movRR(&i.b, &i.b),
		0x41: i.movRR(&i.b, &i.c),
		0x42: i.movRR(&i.b, &i.d),
		0x43: i.movRR(&i.b, &i.e),
		0x44: i.movRR(&i.b, &i.h),
		0x45: i.movRR(&i.b, &i.l),
		0x46: i.movMR(&i.b),
		0x47: i.movRR(&i.b, &i.a),
		0x48: i.movRR(&i.c, &i.b),
		0x49: i.movRR(&i.c, &i.c),
		0x4a: i.movRR(&i.c, &i.d),
		0x4b: i.movRR(&i.c, &i.e),
		0x4c: i.movRR(&i.c, &i.h),
		0x4d: i.movRR(&i.c, &i.l),
		0x4e: i.movMR(&i.c),
		0x4f: i.movRR(&i.c, &i.a),
		0x50: i.movRR(&i.d, &i.b),
		0x51: i.movRR(&i.d, &i.c),
		0x52: i.movRR(&i.d, &i.d),
		0x53: i.movRR(&i.d, &i.e),
		0x54: i.movRR(&i.d, &i.h),
		0x55: i.movRR(&i.d, &i.l),
		0x56: i.movMR(&i.d),
		0x57: i.movRR(&i.d, &i.a),
		0x58: i.movRR(&i.e, &i.b),
		0x59: i.movRR(&i.e, &i.c),
		0x5a: i.movRR(&i.e, &i.d),
		0x5b: i.movRR(&i.e, &i.e),
		0x5c: i.movRR(&i.e, &i.h),
		0x5d: i.movRR(&i.e, &i.l),
		0x5e: i.movMR(&i.e),
		0x5f: i.movRR(&i.e, &i.a),
		0x60: i.movRR(&i.h, &i.b),
		0x61: i.movRR(&i.h, &i.c),
		0x62: i.movRR(&i.h, &i.d),
		0x63: i.movRR(&i.h, &i.e),
		0x64: i.movRR(&i.h, &i.h),
		0x65: i.movRR(&i.h, &i.l),
		0x66: i.movMR(&i.h),
		0x67: i.movRR(&i.h, &i.a),
		0x68: i.movRR(&i.l, &i.b),
		0x69: i.movRR(&i.l, &i.c),
		0x6a: i.movRR(&i.l, &i.d),
		0x6b: i.movRR(&i.l, &i.e),
		0x6c: i.movRR(&i.l, &i.h),
		0x6d: i.movRR(&i.l, &i.l),
		0x6e: i.movMR(&i.l),
		0x6f: i.movRR(&i.l, &i.a),
		0x70: i.movRM(i.b),
		0x71: i.movRM(i.c),
		0x72: i.movRM(i.d),
		0x73: i.movRM(i.e),
		0x74: i.movRM(i.h),
		0x75: i.movRM(i.l),
		0x76: i.hlt,
		0x77: i.movRM(i.a),
		0x78: i.movRR(&i.a, &i.b),
		0x79: i.movRR(&i.a, &i.c),
		0x7a: i.movRR(&i.a, &i.d),
		0x7b: i.movRR(&i.a, &i.e),
		0x7c: i.movRR(&i.a, &i.h),
		0x7d: i.movRR(&i.a, &i.l),
		0x7e: i.movMR(&i.a),
		0x7f: i.movRR(&i.a, &i.a),
		0x80: i.add(i.b),
		0x81: i.add(i.c),
		0x82: i.add(i.d),
		0x83: i.add(i.e),
		0x84: i.add(i.h),
		0x85: i.add(i.l),
		0x86: i.addM,
		0x87: i.add(i.a),
		0x88: i.adc(i.b),
		0x89: i.adc(i.c),
		0x8a: i.adc(i.d),
		0x8b: i.adc(i.e),
		0x8c: i.adc(i.h),
		0x8d: i.adc(i.l),
		0x8e: i.adcM,
		0x8f: i.adc(i.a),
		0x90: i.sub(i.b),
		0x91: i.sub(i.c),
		0x92: i.sub(i.d),
		0x93: i.sub(i.e),
		0x94: i.sub(i.h),
		0x95: i.sub(i.l),
		0x96: i.subM,
		0x97: i.sub(i.a),
		0x98: i.sbb(i.b),
		0x99: i.sbb(i.c),
		0x9a: i.sbb(i.d),
		0x9b: i.sbb(i.e),
		0x9c: i.sbb(i.h),
		0x9d: i.sbb(i.l),
		0x9e: i.sbbM,
		0x9f: i.sbb(i.a),
		0xa0: i.ana(i.b),
		0xa1: i.ana(i.c),
		0xa2: i.ana(i.d),
		0xa3: i.ana(i.e),
		0xa4: i.ana(i.h),
		0xa5: i.ana(i.l),
		0xa6: i.anaM,
		0xa7: i.ana(i.a),
		0xa8: i.xra(i.b),
		0xa9: i.xra(i.c),
		0xaa: i.xra(i.d),
		0xab: i.xra(i.e),
		0xac: i.xra(i.h),
		0xad: i.xra(i.l),
		0xae: i.xraM,
		0xaf: i.xra(i.a),
		0xb0: i.ora(i.b),
		0xb1: i.ora(i.c),
		0xb2: i.ora(i.d),
		0xb3: i.ora(i.e),
		0xb4: i.ora(i.h),
		0xb5: i.ora(i.l),
		0xb6: i.oraM,
		0xb7: i.ora(i.a),
		0xb8: i.cmp(i.b),
		0xb9: i.cmp(i.c),
		0xba: i.cmp(i.d),
		0xbb: i.cmp(i.e),
		0xbc: i.cmp(i.h),
		0xbd: i.cmp(i.l),
		0xbe: i.cmpM,
		0xbf: i.cmp(i.a),
		0xc0: i.rnz,
		0xc1: i.pop(&i.b, &i.c),
		0xc2: i.jnz,
		0xc3: i.jmp,
		0xc4: i.cnz,
		0xc5: i.push(i.b, i.c),
		0xc6: i.adi,
		0xc7: i.rst(0xc7),
		0xc8: i.rz,
		0xc9: i.ret,
		0xca: i.jz,
		0xcb: i.ignore,
		0xcc: i.cz,
		0xcd: i.call,
		0xce: i.aci,
		0xcf: i.rst(0xcf),
		0xd0: i.rnc,
		0xd1: i.pop(&i.d, &i.e),
		0xd2: i.jnc,
		0xd3: i.out,
		0xd4: i.cnc,
		0xd5: i.push(i.d, i.e),
		0xd6: i.sui,
		0xd7: i.rst(0xd7),
		0xd8: i.rc,
		0xd9: i.ignore,
		0xda: i.jc,
		0xdb: i.in,
		0xdc: i.cic,
		0xdd: i.ignore,
		0xde: i.sbi,
		0xdf: i.rst(0xdf),
		0xe0: i.rpo,
		0xe1: i.pop(&i.h, &i.l),
		0xe2: i.jpo,
		//0xe3: xthl,
		0xe4: i.cpo,
		0xe5: i.push(i.h, i.l),
		0xe6: i.ani,
		0xe7: i.rst(0xe7),
		0xe8: i.rpe,
		0xe9: i.pchl,
		0xea: i.jpe,
		//0xeb: xchg,
		0xec: i.cpe,
		0xed: i.ignore,
		//0xee: xri,
		0xef: i.rst(0xef),
		0xf0: i.rp,
		0xf1: i.popPSW,
		0xf2: i.jp,
		0xf3: i.di,
		0xf4: i.cp,
		0xf5: i.pushPSW,
		//0xf6: ori,
		0xf7: i.rst(0xf7),
		0xf8: i.rm,
		//0xf9: sphl,
		0xfa: i.jm,
		0xfb: i.ei,
		0xfc: i.cm,
		0xfd: i.ignore,
		0xfe: i.cpi,
		0xff: i.rst(0xff),
	}
}

// nop is a no-op and just returns the default instruction length.
func (i *Intel8080) nop() uint16 {
	return defaultInstructionLen
}

// ignore is an instruction that is completely ignored and returns the default
// instruction length.
//
// Similar to a no-op but the Intel 8080 data book defines it differently.
func (i *Intel8080) ignore() uint16 {
	return defaultInstructionLen
}
